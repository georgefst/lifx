{-# LANGUAGE GeneralizedNewtypeDeriving, LambdaCase, OverloadedStrings, ScopedTypeVariables #-}

module System.Hardware.Lifx.LanGG where

import System.Hardware.Lifx.Lan.LowLevel.BaseTypes (
      Power()
    , DeviceId
    , HSBK(HSBK)
    , fromText
    )
import System.Hardware.Lifx.Lan.LowLevel.Types (
      MessageType
    , HSBK16
    , Header
    , dfltHdr
    , hdrTarget
    )
import System.Hardware.Lifx.Lan.LowLevel.Messages (
      SetPower(SetPower)
    , SetColor(SetColor)
    , StateLight(..)
    , msgType
    )
import System.Hardware.Lifx.Lan.LowLevel.Protocol (
      serializeMsg
    , ifaceAddr
    , dispatcher
    , noCallback
    )

import Control.Concurrent
import Control.Concurrent.STM.TMVar
import Control.Monad
import qualified Data.ByteString.Lazy as L
import Data.Binary
import Data.Either
import Data.Ord.HT (limit)
import Network.Socket hiding (openSocket)
import Network.Socket.ByteString hiding (sendMsg)

-- TODO
-- acknowledgement of send/receive
-- sequence and source in header
-- shouldnt really be necessary to give both IP and MAC

georgeBulb :: Bulb
georgeBulb = Bulb (SockAddrInet 56700 (tupleToHostAddress (192,168,1,188))) (fromRight (error "illegal bulb id") $ fromText "d073d52d7080")

-- | Turn the bulb on or off
-- (<https://lan.developer.lifx.com/docs/light-messages#section-setpower-117 SetPower>)
setPower :: Bulb       -- ^ the bulb to operate on
            -> Power   -- ^ the new power state for the bulb
            -> Int  -- ^ transition time in milliseconds
            -> IO ()
setPower bulb pwr duration =
    sendMsg bulb dfltHdr (SetPower pwr $ fromIntegral duration)

-- TODO throw errors on out of range (or cap to min and max)
-- | Set the color and intensity of the light generated by the bulb
-- (<https://lan.developer.lifx.com/docs/light-messages#section-setcolor-102 SetColor>)
setColor' :: Bulb      -- ^ the bulb to operate on
            -> (Int,Double,Double,Int) -- ^ new color for the bulb
            -> Int -- ^ fade duration, in milliseconds
            -> IO ()
setColor' bulb (h,s,b,k) duration =
    let hue = fromIntegral ((h * 65535) `div` 360)
        sat = round (s * 65535)
        bright = round (b * 65535)
        kelvin = fromIntegral k
    in  sendMsg bulb dfltHdr (SetColor (HSBK hue sat bright kelvin) $ fromIntegral duration)

-- TODO throw errors on out of range (or cap to min and max)
-- | Set the color and intensity of the light generated by the bulb
-- (<https://lan.developer.lifx.com/docs/light-messages#section-setcolor-102 SetColor>)
setColor :: Bulb      -- ^ the bulb to operate on
            -> HSBK16 -- ^ new color for the bulb
            -> Int -- ^ fade duration, in milliseconds
            -> IO ()
setColor bulb color duration =
    sendMsg bulb dfltHdr (SetColor color $ fromIntegral duration)

--convertTime :: Double -> Word32
--convertTime t = round $ 1000 * t

--hsbk :: Int -> Int -> Int -> Int -> HSBK16
--hsbk h s b k = HSBK (f h) (f s) (f b) (f k) where f n = fromIntegral $ n * 65535 `div` 10

sendMsg :: (MessageType a, Binary a) => Bulb -> Header -> a -> IO ()
sendMsg (Bulb sa targ) hdr payload = do
    sock <- openSocket --TODO hmm every time?
    sendAllTo sock (L.toStrict pkt) sa
    print sa
    where pkt = serializeMsg (hdr { hdrTarget = targ }) payload

--TODO tmp (has socket passed in)
sendMsg' :: (MessageType a, Binary a) => Socket -> Bulb -> Header -> a -> IO ()
sendMsg' sock (Bulb sa targ) hdr payload =
    sendAllTo sock (L.toStrict pkt) sa
    where pkt = serializeMsg (hdr { hdrTarget = targ }) payload

openSocket :: IO Socket
openSocket = do
    hostAddr <- ifaceAddr Nothing
    sock <- socket AF_INET Datagram defaultProtocol
    bind sock $ SockAddrInet defaultPort hostAddr
    when (isSupportedSocketOption Broadcast) (setSocketOption sock Broadcast 1)
    tmv <- newEmptyTMVarIO
    _ <- forkFinally (dispatcher tmv) (const $ close sock)
    return sock


data GetLight = GetLight

instance MessageType GetLight where
    msgType _ = 101

instance Binary GetLight where
    put _ = return ()
    get = return GetLight


--TODO retry on failure from noCallback
--TODO possible that socket is getting GC-ed
-- | Get information about the bulb's current state
-- (<https://lan.developer.lifx.com/docs/light-messages#section-get-101 Get>)
getLightGG :: Bulb -> IO (Maybe StateLight)
getLightGG bulb = do
    res <- newEmptyMVar
    sock <- openSocket
    _ <- forkIO $ noCallback res sock
    sendMsg' sock bulb dfltHdr GetLight
    takeMVar res >>= \case
        Left e -> do
            putStrLn "FAILED."
            print e
            return Nothing
        Right r ->
            return $ Just r


-- | Type representing one LIFX bulb
data Bulb = Bulb SockAddr DeviceId deriving (Show, Eq, Ord)


class Inc a where
    inc :: Int -> a -> a

newtype H = H Word16 deriving (Bounded,Enum,Eq,Show)
instance Inc H where -- wrap around
    inc n = H . toEnum . (`mod` (1 + fromEnum (maxBound :: Word16))) . (+n) . fromEnum

newtype S = S Word16 deriving (Bounded,Enum,Eq,Ord,Show)
instance Inc S where
    inc = inc'

newtype B = B Word16 deriving (Bounded,Enum,Eq,Ord,Show)
instance Inc B where
    inc = inc'

newtype K = K Word16 deriving (Eq,Ord,Show)
instance Bounded K where
    minBound = K 2500
    maxBound = K 9000
instance Enum K where -- only allow values between minBound and maxBound
    toEnum = K . toEnum . checkBounds (fromEnum (minBound :: K), fromEnum (maxBound :: K))
    fromEnum (K x) = fromEnum x
instance Inc K where
    inc = inc'




-- add n, limited to between (minBound,maxBound)
inc' :: forall a . (Bounded a, Enum a) => Int -> a -> a
inc' n = toEnum . limit (fromEnum (minBound :: a), fromEnum (maxBound :: a)) . (n +) . fromEnum

-- unsafe version of limit
checkBounds :: Ord p => (p, p) -> p -> p
checkBounds (l,u) x = if x < l || x > u then error "out of range" else x
